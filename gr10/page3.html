<!DOCTYPE html>
<html lang="fr">
	<head>
		<title>Mini-projet de stéganographie</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" href="../style.css">
	</head>

	<body>
		<div class="header">
			<img src="../images/logo_NSI_mechain.jpg" alt="logo nsi" width=300>
		</div>

		<div class="topnav">
			<a href="/TP_images/nsi1_2023/index.html">Accueil</a>
			<a href="index.html">Thème</a>
			<a href="page1.html">Principe mis en oeuvre</a>
			<a href="page2.html">Programme Python</a>
			<a class="active" href="page3.html">Compléments</a>
		</div>
 
		<div class="row">
			<div class="column side">
				<img src="../images/logo-nsi.png" alt="logo nsi" width = 100 align="left">
			</div>
  
			<div class="column middle">
				<h2>Compléments</h2>
				
				
				<div style="text-align:left">
				
					<h5 style="font-size-adjust:0.75">Nous avons donc vu ici comment cacher une image dans une autre de même résolution grâce au chiffrage des couleurs. Nous pourrions enrichir ce travail de 
					plusieurs façons :</h5>
					
					<ul>
						<li>Déchiffrer l'image cachée : ce qui est déjà possible dans le programme donnée grâce à une deuxième fonction</li>
						<li>Faire marcher le programme pour des fichiers d'images avec d'autres modes : par exemple il ne marche qu'ici avec des images de mode "RGB" et une 
						extension en .png pour que ce soit assez transparent mais on pourrait essayer de rendre le chiffrement accfesible à plus d'images comme des images en 
						mode "P" utilisant des palettes par exemple</li>
						<br />
						<li>Coder un programme qui s'adapte à toutes dimensions d'images et calcule le nombre de bits optimal à cacher pour avoir la meilleure qualité d'image 
						déchiffrée :</li>
						<ul>
							<li>on pourrait par exemple avec une image réceptacle deux fois plus grande que celle chiffrée cacher tous les bits de l'image cachée dans 
							l'image à cacher en les divisant en deux et cacher un octet dans deux octets soit alterner entre 4 MSB et 4 LSB dans les 4 LSB de l'image receptacle.</li>
							<li>peut-être aussi essayer de garder une bonne qualité d'image réceptacle et donc ne presque pas voir l'image cachée dans tous les cas. Par exemple ne 
							cacher qu'un bit d'image cachée par octet quand l'image réceptacle est vraiment très grande. On aurait alors les 7 MSB de l'image réceptacle avec le bit 1
							puis 2 jusqu'à 8 dans le LSB de l'image réceptacle.</li>
							<li>en allant plus loin, on pourrait donc à partir des dimensions des deux images et de leurs nuances qui les rendent plus où moins transparentes 
							imaginer une fonction chiffrer() qui donne une image chiffrée contenant deux images avec des qualités optimisées en partageant les octets en compléments de 8.</li>
						</ul>
					</ul>
					
				</div>
			</div>
  
			<div class="column side">
				<img src="../images/logo-python.png" alt="logo python" width = 100 align="right">
			</div>
		</div>
		
		<div class="footer">
			<h3>Spécialité NSI - Lycée Pierre Méchain LAON</h3>
		</div>

	</body>
</html>
